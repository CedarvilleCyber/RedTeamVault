Login to Linux host from Windows host: 172.16.5.225
htb-student:HTB_@cademy_stdnt!

Once we gain a foothold in the domain, our goal shifts to moving laterally or vertically to gain access to more hosts, furthering our chances at domain admin.

**If we have local admin rights,** we may be able to use Pass-The-Hash

**What if we don't have local admin rights?** 
1. RDP?
2. Powershell remoting or WinRM access?
3. Do you have MSSQL Server access?

#### How do we enumerate the above?
Utilize **bloodhound** with these queries: 
1. CanRDP
	1. Even if a user does not have local admin anywhere, they may be able to RDP, and gather more key information.
	2. **Does the domain users group have local admin rights or execution rights (such as rdp or winrm) over one or more hosts?**
2. CanPSRemote
3. SQLAdmin

**Powerview** and **Built-in** tools can also be used.

--> See who is a part of the "Remote Desktop Users"
````powershell-session
Get-NetLocalGroupMember -ComputerName ACADEMY-EA-MS01 -GroupName "Remote Desktop Users"
````
![[Pasted image 20250618155736.png]]
All domain users can remote desktop!

### Utilize `Enter-PSSession`
```powershell-session
$password = ConvertTo-SecureString "Klmcargo2" -AsPlainText -Force

$cred = new-object System.Management.Automation.PSCredential ("INLANEFREIGHT\forend", $password)

Enter-PSSession -ComputerName ACADEMY-EA-MS01 -Credential $cred
```


## Utilize `evil-winrm`:
`evil-winrm -i <ip> -u <user>`


## Utilize `PowerUPSQL`
```powershell-session
cd .\PowerUpSQL\

Import-Module .\PowerUpSQL.ps1

Get-SQLInstanceDomain
```

This give info that `Dana Amundsen` can connect via MSSQL on this server
![[Pasted image 20250618161907.png]]
==Connect via `Get-SQLQuery`==
```powershell-session
Get-SQLQuery -Verbose -Instance "172.16.5.150,1433" -username "inlanefreight\damundsen" -password "SQL1234!" -query 'Select @@version'
```
##### Or on Linux:
`mssqlclient.py inlanefreight.local/damundsen@172.16.5.150 -windows-auth`


## Kerberos "Double Hop" Problem:

The **double hop problem** occurs when:
1. **Hop 1**: You authenticate to **Machine A** using Kerberos.
2. **Hop 2**: You try to have **Machine A** authenticate on your behalf to **Machine B** â€” but it **fails**, because **your Kerberos ticket is not forwarded**.

Kerberos tickets are **not** a password, they are signed pieces of data that state *what resources* an account can access.

**Bottom line**:
- When you use a Kerberos ticket to authenticate, the password is **not** stored in memory
- When you use a password, the password **is** stored in memory

^^ This creates problem if you jump to a host from an initial target, because your credentials will not be stored in memory, resulting in failed authentication.

### 2 Workarounds to double hop problem:

1. Create a PSCredential object 

```powershell
$SecPassword = ConvertTo-SecureString '!qazXSW@' -AsPlainText -Force
# Create a password variable

$Cred = New-Object System.Management.Automation.PSCredential('INLANEFREIGHT\backupadm', $SecPassword)
# Store cred

```

The ABOVE commands will allow us (with a evil-winrm session on host A) run commands against host B
```Powershell
get-domainuser -spn -credential $Cred | select samaccountname
```

